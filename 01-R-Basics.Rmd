
```{r, echo=FALSE, eval=TRUE}
klippy::klippy()
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```

```{r library01, echo=F, eval=T}
library(htmltools)
```


# R Basics


## What are R and RStudio?

```{r}
version$major #
```

  * If not "4" or above, please upgrade your R.

```{r}
rstudioapi::versionInfo()$version
```

  * If not "1.4.1717" or above, please upgrade your RStudio

<img src="https://d33wubrfki0l68.cloudfront.net/0b4d0569b2ddf6147da90b110fbb2a17653c8b08/f06f3/images/shutterstock/r_vs_rstudio_1.png" alt="Analogy of difference between R and RStudio." width="95%">

  * R: engine, or the hardware of the entire car parts other than its dashboard.
  
  * RStudio: dashboard. A lot of user-friendly features for you to drive a car easily.

## Environment setup

### RStudio

> A Integrated Developement Environment (IDE)

**Tools** > **Global Options**

  * Show white space: **Code** > **Display** > "Show whitespace characters"
  
  * Protect your eyes: **Appearance** > **Editor theme**: Tomorrow Night
  
  * Layout (optional): **Pane Layout** > Put **Source** and **Console** as the top two panes.
  
<div class="alert alert-danger">
Save with encoding:
Tools > Global Options > Code > Saving:

  * Default text encoding: **UTF-8**
  
This is very important if you are using non-English characters in your program.
</div>


***

For R markdown: **File** > **New File** > **R Markdown...**,

**Tools** > 

  * **Modify Keyboard Shortcuts**: 
  name=`Insert Chunk`.

### R

To check:
```{r}
Sys.getenv()
```

#### Error message language

> Every programmers learn a lot from error messages. 

```{r}
2+x
```

<div class="alert alert-info">
Set console message to English:
```{r}
Sys.setenv(LANG = "en")
```

Another way to set it in **.Renviron** file:
```{r}
install.packages("startup")
```

```{r}
startup::find_renviron()
```


```{r}
# if there is one
file.edit(startup::find_renviron())
# if there is none
file.edit("~/.Renviron")
```

Then put
```
LANG = "en"
```
and save. Then restart R.

More information regarding R environment can be found in [startup](https://cran.r-project.org/web/packages/startup/vignettes/startup-intro.html) package.
</div>

## Project

> If there is a reason for your to program, then the reason is good enough to become a project.

  * Project: a folder under which the relations between documents saved underneath that folder is well defined--most of the time, self-sufficient.
  
  * Keep your programs that serve the same purpose underneath the same project will help your programs reproducible in the future. 
  
  
### Start a project in RStudio

On the top right corner:
**New Project...** > **New Directory** > **New Project**

If you are in a project, 

  * your top right corner will show your project name.
  
  * Your **File** panel will have a return-to-project-root icon.
  
  * you should save all your files within the project folder.
  
## R Script/R Markdown

  * **Console** window is an interactive environment. Once you hit **enter**, the command is executed.
  
***

If you want to save a bunch of commands (called **script**) in one file, you can choose **File** > **New File** > :

  * **R script** (.R file): purely R commands. Good for developing an app.
  
  * **R Markdown** or **R Notebook** (.Rmd file): mixture of R commands and text (in a style called markdown). Good for learning, and experimenting codes (which code line to keep? which not?) 
  
## Basic data type

For **ONE** value, there are three major basic types of storage:

  * character (sometimes called string):
  
```{r}
"Mary"
'Friday'
```

  
  * numeric:
  
```{r}
2L # integer
3.1412 # double (non-integer real number)
2 # double
```

  * logical
  
```{r}
TRUE
FALSE
T
F
```
  
```{r, eval=T, echo=F}
tags$img(src="https://d33wubrfki0l68.cloudfront.net/eb6730b841e32292d9ff36b33a590e24b6221f43/57192/diagrams/vectors/summary-tree-atomic.png")
```

## Collection of values

When facing a collection of values, R has two types of data collection:

  * Atomic vector: vector with all values of **the same** type
  
```{r}
c("John", "Mary")
c(2, 3.1412)
c(TRUE, TRUE, F)
```

  * list (or general vector): vector of values of **different types** (though the same type is allowed).
  
```{r}
list("John", 178, TRUE)
```


<div class="alert alert-info">
Atomic vector's type is determined by its element values:
```{r}
typeof(c("John", "Mary"))
```

list's type is **list**:
```{r}
typeof(list("John", 178, TRUE))
```

</div>

## Values and element values

A single basic type value (aka **singleton**) such as a character (`"John"`), a number (`5`), and a logical (`TRUE`) is a value, but a vector itself (no matter atomoic vector or list) can mean **one** value too.

The following can all be considered **one** value:
```{r}
"John"
5
TRUE
list("John", 5, TRUE)
c(5, 7, 9)
```

Within a vector, the values inside the vector are called its **element** value. 

```{r}
list("John", 5, TRUE) # has 3 element values.
```

For **list** it can contain almost anything inside, even another list such as:
```{r}
list("John",42, list("Mary", 35)) # big list (a nested list)
```

Within a vector, **each** element value is:

  * separated by `,` ; and
  
  * not sitting inside another vector.

Therefore, the above vector has the following three element values:  
```{r}
"John"
42
list("Mary", 35)
```

  * You **CANNOT** say `"Mary"` is an element value of the big list, since it sits inside another vector.

## Retrieve element value by Position

**Position**: For a collection of element values separated by `,`, each value has a position (or location) reference, with 1 be the 1st value, 2 be the 2nd value, 3 be the 3rd value, etc. (i.e. the counting of position starts from 1.) 

We can retrieve a value from the vector (no matter atomic or list) using `[[]]` **double bracket** operator:

```{r}
c("John", "Mary")[[1]]
c("John", "Mary")[[2]]
```

```{r}
list("John", 178, TRUE)[[1]]
list("John", 178, TRUE)[[2]]
list("John", 178, TRUE)[[3]]
```

<div class="exercise">

Try `[[]]` on:
```{r}
list("John",42, list("Mary", 35))
```

</div>

***

**Chained extraction operations**

`[[x]]` can be followed immediately by another `[[y]]`, 

  * R will resolve the extraction **sequentially** from the leftest extraction (`[[x]]`) to the rightest extraction (`[[y]]`)


```{r}
bigList <- list("John",42, list("Mary", 35))
bigList[[3]][[2]]
```

  * The leftest extraction `[[3]]`, so R resolves `bigList[[3]]` first. It will return `list("Mary", 35)`. 
  
  * The rightest extraction `[[2]]`, so R now resolves `list("Mary", 35)[[2]]`. 
  
  * At the end we get `35`. 



## Binding

To operate on a value, lots of time it is more convenient if we can recreate a name as a reference to the values.  When we call that name, R will know we are asking for the values it represent. This requires **binding** a name to some value. 

When we assign a **name** with **values**, it is called **binding**.

```{r}
personName = c("John", "Mary")
interestingNumber = c(2, 3.1412)
covidPositive = c(TRUE, TRUE, F)
```

name call
```{r}
personName
```

***
R's special arrow binding:

```{r}
personName <- c("John", "Mary")
interestingNumber <- c(2, 3.1412)
covidPositive <- c(TRUE, TRUE, F)
```

```{r}
c("John", "Mary") -> personName
c(2, 3.1412) -> interestingNumber
c(TRUE, TRUE, F) -> covidPositive
```

***

When we bind a collection of values to a name, the name can be used to recall its underlying values:

```{r}
personName <- c("John", "Mary")
```

```{r}
personName
```

In addition, to retrieve:
```{r}
c("John", "Mary")[[2]]
```
you can:
```{r}
personName[[2]]
```

<div class="alert alert-warning">
Whenever there is name calling in a code line, R will retrieve the value binding with the name first, then continue the rest of the code execution

That is why when R sees
```{r}
personName[[2]]
```

it will resolve the value of the name (which is `c("John", "Mary")[[2]]`), and execute the following implicitly:
```{r}
c("John", "Mary")[[2]]
```

</div>

***

Consider
```{r}
element1 <- "a"
element2 <- "b"
```

The following code line involved with two names `element1` and `element2`
```{r}
c(element1, element2) # there are two name calls
```

When running the line R will replace `element1` with "a" and `element2` with "b" first, then execute the resulting line:

```{r}
c("a", "b")
```

***

<div class="alert alert-info">
Common naming styles:

  * camel: `personName <- c("John", "Mary")`
  
  * snake: `person_name <- c("John", "Mary")`
</div>

<div class="alert alert-info">
Some common practice:

  * regular name starts with **small case**.
  
  * constructor (will be explained in the future) name starts with **Capital** letter.
</div>

***

<div class="alert alert-info">
A **regular valid** name starts with:
  
  * a letter;
  
  * or the dot not followed by a number.

```{r}
.onePerson = "Mary" # regular
onePerson= "Marty" # regular
.1person = "Mary"
```

```{r}
example <- c(200, 1.25)
.example <- c("password: 28dlso")
```

A valid name (also called symbol) consists of: letters, numbers and the dot (.) or underline (_) characters.

```{r}
`姓名` <- "Martin"
```
backticks

```{r}
``
""
''
```

my class students this semester
```{r}
myClassStudentsThisSemester <- c("Mary", "John") 
my_class_students_this_semester <- c("Mary", "John")
```



</div>

<div class="alert alert-success">

Which one is valid? Which one is valid but not regular?

```{r, echo=T, eval=F}
my_108_total_credits <- 15
_108_total_credits <- 15
108_total_credits <- 15
_my_108_total_credits <- 15
my.108.total_credits <- 15
.108.total_credits <- 15 
.my.108.total_credits <- 15 # start with . will hide name
`.108.total_credits` <- 15 # irregular name, ` is not part of the name
`.108.total_credits` <- 15
`108 total credits` <- 15
```

</div>





## Concatenate

`c()` where c comes from **concatenate**, meaning chaining together all element values of input value as element values in one vector:

  * its input values must be **of the same type**.
  
  * if input value is a vector, its element values will be taken out. All taken-out element values, will be packed together as **one** vector.
  
  * Then newly packed **one** vector has the type as the source input values.

```{r}
typeof(c("a", "b"))
typeof(c("c", "d"))
c(c("a", "b"), c("c", "d")) 
```

  * source values `c("a", "b")` and `c("c", "d")`
  
  * `c(two source values)` chains all values together as

```{r}
c("a", "b", "c", "d")
```

<div class="alert alert-info">
Concatenate atomic vectors (i.e. vector of `c(...)`) will always result in an atomic vectors (i.e. still a `c(...)` vector)

</div>

***

```{r}
c(list("a", 1), list("c", 2))
```

  * source values: `list("a", 1)` and `list("c", 2)`.
  
  * `c(two source values)` chains all values together as

```{r}
list("a", 1, "c", 2) 
```

<div class="alert alert-info">
Concatenate list vectors (i.e. vector of `list(...)`) will always result in an list vectors (i.e. still a `list(...)` vector)
</div>

## List

**list**  

  * can take in all types of values -- even a list.
  
```{r}
list(c("a", "b"), c("c", "d")) # (1)
```

  * but it does not chain element values inside each element values.

```{r}
# so (1) is not the same as
list("a", "b", "c", "d")
```


```{r}
c(c("a", "b"), c("c", "d"))[[1]]
c(c("a", "b"), c("c", "d"))[[2]]
c(c("a", "b"), c("c", "d"))[[3]]
c(c("a", "b"), c("c", "d"))[[4]]
list(c("a", "b"), c("c", "d"))[[1]]
list(c("a", "b"), c("c", "d"))[[2]]
list(c("a", "b"), c("c", "d"))[[3]] # Error

```

<div class="alert alert-danger">
Data type **coercion**.

```{r}
coercion <- c(c("a", "b"), c(1, 22))

typeof(coercion[[3]])
```

When you concatenate values of different types, since `c()` will return only an vector with all element values having the same type. It will choose one type and coerce other type of value into that chosen type.

Each type is designed to deal with different operations, like `+` is for numeric value. Operations on wrong types of values will produce error:
```{r}
1 + 2
coercion[[3]] + 2
```


</div>


## Sampled data

In social science, it is common to survey a sampled group of people from the entire population. For each interviewee, we may collect his/her age, gender, residential district, etc. These are called **features** of interviewee.


```{r , eval=T, echo=F}
teachDS::img_centering(
  src="assets/img/survey.jpeg", "80%"
)
```

  * Each feature has its own type of information.

How do we store these four person's data? (Each person's data is called **one observation**.) There are two common ways to storing their data:

  * Observation by observation
  
  * Feature by feature
  
### Observation by observation

  * store each observation completely, then put them together

```{r}
list(54, "male", "north", 100) # (1)
list(32, "female", "south", 25) # (2)
list(28, "female", "east") # (3)
list(20, "male", "east", 77) # (4)
```

<div class="alert alert-info">
Observation (3) does not have a fourth element because it is missing. However, **missing** itself is still considered valuable information. We normally put down `NA`, i.e. 
```{r}
list(28, "female", "east", NA) # (3)
```

</div>

Put them together
```{r}
list(
  list(54, "male", "north", 100), # (1)
  list(32, "female", "south", 25), # (2)
  list(28, "female", "east", NA), # (3)
  list(20, "male", "east", 77) # (4)
)
```

<div class="exercise">
Why don't we use:

```{r}
c(
  list(54, "male", "north", 100), # (1)
  list(32, "female", "south", 25), # (2)
  list(28, "female", "east", NA), # (3)
  list(20, "male", "east", 77) # (4)
)
```

</div>

<div class="alert alert-info">
`#` means **comment**. R will ignore `#` and anything follows it in that line. So the above code in R's eyes is like:
```{r}
list(
  list(age = 54, gender="male", residence="north", income=100),
  list(age=32, gender="female", residence="south", income=25), 
  list(28, "female", "east", NA), 
  list(20, "male", "east", 77) 
) -> dataSet2
dataSet2[[2]][["age"]]
```

In addition, R gives users a great flexibility of line breaking. You can break a line of code pretty much any where before the line end so long as
  
  * R finds the command is **incomplete**.
  
```{r}
list(list(54, "male", "north", 100), # incomplete
  list(32, "female", "south", 25)) # is the same as

list(
  list(54, "male", "north", 100), 
  list(32, "female", "south", 25)) # also

list(
  list(54, "male", "north", 100), 
  list(32, "female", "south", 25)
  ) # also

list(
  list(54, 
    "male", 
    "north", 
    100), 
  list(32, "female", "south", 25)
  ) # also

```


```{r}
3 + 2 # should not be broken into

3  # because a command line 3 can be complete command
 +2
```


  * R does not care indentation, so the followings are the same as above:

```{r}
list(
list(54, "male", "north", 100), 
list(32, "female", "south", 25)
) # also

list(
list(54, 
  "male", 
  "north", 
  100), 
list(32, "female", "south", 25)
) # also
```


</div>

### Feature by feature

  * store each feature completely, then put them together
  
```{r}
c(54, 32, 28, 20) # age
c("male", "female", "female", "male") # gender
c("north", "south", "east", "east") # residence
c(100, 25, NA, 77) # income
```

Putting together
```{r}
list(
  c(54, 32, 28, 20), # age
  c("male", "female", "female", "male"), # gender
  c("north", "south", "east", "east"), # residence
  c(100, 25, NA, 77) # income  
)
```

<div class="alert alert-danger">
You can not use `c()` to collect all features together. 

  * It will chained all inputs' element values together.
  
  * Since it only accommodates element values of the same type, it will coerce them into a single type (mostly character).

```{r}
c(
  c(54, 32, 28, 20), # age
  c("male", "female", "female", "male"), # gender
  c("north", "south", "east", "east"), # residence
  c(100, 25, NA, 77) # income  
)
```

It will become:
```{r}
c(
  "54", "32", "28", "20", 
  "male", "female", "female", "male", 
  "north", "south", "east", "east", 
  "100", "25", NA, "77"   
)
```


</div>

<div class="exercise">
Name its values:
```{r}
list(
  c(54, 32, 28, 20), # age
  c("male", "female", "female", "male"), # gender
  c("north", "south", "east", "east"), # residence
  c(100, 25, NA, 77) # income  
)
```

</div>

<!--
<div class="exercise">
Any value can be named. A value can be a singleton, an atomic vector, a list, etc. Try to name every feature value inside each observation:
```{r}
list(
  list(54, "male", "north", 100), 
  list(32, "female", "south", 25), 
  list(28, "female", "east", NA), 
  list(20, "male", "east", 77), 
)
```

</div>

-->

## Named element values

In a vector, we can give **each element value** **a name**, using `"name"=value` assignment.


```{r}
c(177, 160, 170)
c('John'=177, 'Mary'= 160, 'Bill'=170)[["John"]]
# atomic vector
c("John"=177, "Mary"=160, "Bill"=170)
# list
list("John"=177, "Mary"=160, "Bill"=170)
```

  * The name is given to element value, no matter the element value is a singleton or not.

```{r}
list(
  "1st Observation"=list(54, "male", "north", 100), 
  "2nd Observation"=list(32, "female", "south", 25), 
  "3rd Observation"=list(28, "female", "east", NA), 
  "4th Observation"=list(20, "male", "east", 77), 
)
```


```{r}
list(
  "age"=c(54, 32, 28, 20), # age
  "gender"=c("male", "female", "female", "male"), # gender
  "residence"=c("north", "south", "east", "east"), # residence
  "income"=c(100, 25, NA, 77) # income  
) -> dataSet
dataSet[["income"]]
dataSet[[4]]
```


  * You can also use ``` `` ```, such as ```list(`first Observation`=..., `second Observation`=...)```
  
  * If name is regular, you can even ignore the quotation, such as
```{r}
list(
  firstObservation=list(54, "male", "north", 100), 
  secondObservation=list(32, "female", "south", 25))
```
  


***

When you give element values names, you can retrieve the value not only by its position, but also by its name

```{r}
personName[[2]]
personName_nameValuePair[[2]]
personName_nameValuePair[["the_second_person"]]
```


<div class="alert alert-danger">
To give element value a name, 

  * You **MUST** use `=`, 
  
  * you CANNOT use `<-` or `->`.

```{r}
personName_nameValuePair <- c("the_1st_person" <- "John", "the_second_person" <- "Mary")
```

```{r}
list(
  firstObservation = list(54, "male", "north", 100), 
  secondObservation = list(32, "female", "south", 25))
```

  * `<-` or `->` is **merely** for binding purpose. 
  
  * vectors with binding inside will be interpreted as name-value **binding** followed immediately by **name call**. In the list case, it is equivalent to:

```{r}
# name-value binding
firstObservation <- list(54, "male", "north", 100)
secondObservation <- list(32, "female", "south", 25)
# name call
list(
  firstObservation, secondObservation 
  )
```

  * The element values in the list are NOT named as a result.

</div>


## Retrieve element value by element name

If an element value has name (to be more precisely **element name**), you can extract it by its name
```{r}
sample_data <- 
  list(
    "1st Observation"=list(54, "male", "north", 100), 
    "2nd Observation"=list(32, "female", "south", 25), 
    "3rd Observation"=list(28, "female", "east", NA), 
    "4th Observation"=list(20, "male", "east", 77)
  )
sample_data[["4th Observation"]]
```

<div class="alert alert-info">
So far we know we can use `[[x]]` to extract an element value of an object, where `x` is either 

  *  a location index: 1, 2, 3, etc. or;
  
  *  an element name if the element value has a name: `"value_name"` where `" "` is required **no matter value_name is regular or not**. 
  
```{r}
a <- c(1, 3, elementName=7)
a[[1]]
a[["elementName"]]
```

But not
```{r}
a[[elementName]] 
a[[`elementName`]]
```

  * `elementName` and ``` `elementName` ``` are both considered name **call**. R would try to find its binding value, and replace the object name with its binding value.

</div>

<div class="exercise">

Do you understand why the following works:
```{r}
targetName <- "elementName"
a[[targetName]]
```

</div>

## list only $ extractor

List has a privilege on extraction when you want to **extract by name**. Other than `[["value_name"]]` you can also use `$"value_name"` or ```$``value_name`` ```, or when value_name is regular, `$value_name`.

```{r}
sample_data <- list(
  "observation1"=list(54, "male", "north", 100), 
  "observation2"=list(32, "female", "south", 25), 
  "observation3"=list(28, "female", "east", NA), 
  "observation4"=list(20, "male", "east", 77)
)
sample_data[["observation4"]]

sample_data$"observation4"

sample_data$`observation4`

sample_data$observation4
```

